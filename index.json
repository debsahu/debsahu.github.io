[{"content":"    Home Assistant Switch for 8 Relays: PCF8574 can be used to extend the GPIO of ESP8266/32 and here we use 8 ports of PCF8574 to control 8 Relay module\nGitHub: debsahu/PCF8574_8Relay Home Assistant Switch for 8 Relays\n Code can compile on ESP8266/32 PCF8574 can be used to extend the GPIO of ESP8266/32 8 ports of PCF8574 is connected to 8 Relay module  Libraries Needed platformio.ini is included, use PlatformIO and it will take care of installing the following libraries.\n   Library Link     MQTT https://github.com/256dpi/arduino-mqtt   ArduinoJson v6 https://github.com/bblanchon/ArduinoJson   WiFiManager Develop https://github.com/tzapu/WiFiManager/archive/development.zip   PCF8574 Library https://github.com/xreef/PCF8574_library   Arduino WebSockets https://github.com/Links2004/arduinoWebSockets   UpdateUploadServer (ESP8266) https://github.com/debsahu/DDUpdateUploadServer    Hardware Items  ESP8266 (aliexpress) / ESP32 (aliexpress) 3.3V to 5V converter (aliexpress) PCF8574AP (aliexpress) 8-port relay (aliexpress) Plastic Box (amazon) AC plug socket (aliexpress) 3-pin AC cable (aliexpress) 2 sockets (Home Depot)  Instructions  Break the tab on the sides with brass screws Connect each of the brass screws to Normally Open (N/O) on relay   Use PCF8574AP (exact version used here) Use 3.3V to 5V level shifters for ESP8266 I2C data Set A0, A1, A2 to GND so I2C address is 0x20 Use 5V as VCC on PCF8574AP Use a good 110V AC to 5V DC device like a phone charger  ","permalink":"https://www.debashishsahu.com/posts/esp8266-esp3232-home-assistant-switch-connected-to-pcf8574-controlling-8-ac-relays/","summary":"Home Assistant Switch for 8 Relays: PCF8574 can be used to extend the GPIO of ESP8266/32 and here we use 8 ports of PCF8574 to control 8 Relay module\nGitHub: debsahu/PCF8574_8Relay Home Assistant Switch for 8 Relays\n Code can compile on ESP8266/32 PCF8574 can be used to extend the GPIO of ESP8266/32 8 ports of PCF8574 is connected to 8 Relay module  Libraries Needed platformio.","title":"ESP8266 ESP3232 Home Assistant Switch Connected to PCF8574 Controlling 8 AC Relays"},{"content":"   Don\u0026rsquo;t confuse Masala Chai with Chai Latte, no not the same thing! While we make chai during the snowy season, lets connect ESP8266/32 to Amazon\u0026rsquo;s AWS IoT in less than 5 minutes.\nAWS IoT Core Instructions Goto AWS IoT Core on your AWS console\nCreate a Policy   Generate a Policy first   Create a Policy details\n   Provide a Name Action: iot:* Resource ARM: * Effect: Allow   Create a Thing   Create a Thing first   Single Thing\n   Create a AWS IoT Thing   Thing Name   Provide a Name to the Thing Copy thing name into THINGNAME Click Next   Create Certificates   Click on Create Certificate   Download Certificates Download the following   Contents for client_cert[] from XXXXXXXXXX.cert.pem Contents for privkey[] from XXXXXXXXXX.private.key Contents for cacert[] from Root CA for AWS   Download the Root CA Certificate   Download the RSA 2048 bit key    Attached the Policy created from step above   Interact with AWs IoT Core\n   look for HTTP end point and copt it into MQTT_HOST[] Copy thing name into THINGNAME (same name from step 3)   Software requirements ESP8266\n Use ESP8266 Arduino Core version 2.5.0-beta2 or greater Will NOT work on ESP8266 Arduino Core v2.4.2 !!!  ESP32\n Use the latest release version  Libraries Needed platformio.ini is included, use PlatformIO and it will take care of installing the following libraries.\n   Library Link Purpose     Arduino MQTT https://github.com/256dpi/arduino-mqtt communication (choose 1)   PubSubClient https://github.com/knolleary/pubsubclient communication (choose 1)   ArduinoJSON https://github.com/bblanchon/ArduinoJson example-data-formatting    ","permalink":"https://www.debashishsahu.com/posts/connect-to-aws-iot-while-making-masala-chai-asmr/","summary":"Don\u0026rsquo;t confuse Masala Chai with Chai Latte, no not the same thing! While we make chai during the snowy season, lets connect ESP8266/32 to Amazon\u0026rsquo;s AWS IoT in less than 5 minutes.\nAWS IoT Core Instructions Goto AWS IoT Core on your AWS console\nCreate a Policy   Generate a Policy first   Create a Policy details\n   Provide a Name Action: iot:* Resource ARM: * Effect: Allow   Create a Thing   Create a Thing first   Single Thing","title":"Connect to AWS IoT While Making Masala Chai [ASMR]"},{"content":"    ⚠️ ⚠️ ⚠️ ARTIK Cloud has been depcreciated by Samsung ⚠️ ⚠️ ⚠️ Here we create an ESP8266/32 based device that emulates a RGB LED light using NeoPixels, which connects to ATRIK cloud. ARTIK cloud connects to smart home assistants like Google Home, Amazon Alexa, etc.\nConnecting to Samsung ARTIK Cloud https://my.artik.cloud/\nGitHub: debsahu/ARTIKCloud An application made for ESP8266 to comunicate with ARTIK Cloud\n Connects to ARTIK Cloud via MQTT SSL port 8883 ARTIK Cloud is connected to all assistant platforms, integration is seamless Compiles on ESP8266-arduino core v2.4.2, v2.5.0-beta3, git version  ARTIK Cloud Instructions ARTIK Cloud Developer  Create a Device Type   Click on Device Type Add a new device + New Device Type   Provide a Name for this device type   Provide a Device Display Name Add an unique name: com.user.devicetype   Create/Upload a Manifest   Use the manifest provided for RGB lights   Activate Manifest  ARTIK My Cloud  Create an end-product \u0026ldquo;Device\u0026rdquo;   Click on \u0026ldquo;Devices\u0026rdquo; -\u0026gt; \u0026ldquo;+Add Another Device\u0026hellip;\u0026rdquo; -\u0026gt; Select Device Display Name Provide a YouTube Lights \u0026laquo; this will show up on your assistants Click on Add Device  Generate a TOKEN   Click on Generate Device Token\u0026hellip;  MQTT Libraries Needed platformio.ini is included, use PlatformIO and it will take care of installing the following libraries.\n   Library Link      ESPAsyncUDP https://github.com/me-no-dev/ESPAsyncUDP    ESPAsyncTCP https://github.com/me-no-dev/ESPAsyncTCP    Adafruit NeoPixel https://github.com/adafruit/Adafruit_NeoPixel    NeoPixelBus https://github.com/Makuna/NeoPixelBus optional: #define USE_NEOPIXELBUS   ESPAsyncWiFiManager https://github.com/alanswx/ESPAsyncWiFiManager #define USE_WIFIMANAGER   ESPAsyncDNSServer https://github.com/devyte/ESPAsyncDNSServer    ESP Async WebServer https://github.com/me-no-dev/ESPAsyncWebServer #define USE_ASYNC_WEBSERVER   ArduinoJson https://github.com/bblanchon/ArduinoJson    WebSockets https://github.com/Links2004/arduinoWebSockets optional: //#define USE_ASYNC_WEBSERVER   WiFiManager https://github.com/tzapu/WiFiManager optional: //#define USE_ASYNC_WEBSERVER \u0026amp; #define USE_WIFIMANAGER    ESP32 Check this issue for latest progress.\nHardware  Connect 5V to + of WS2812B and VIN of NodeMCU or voltage regulator in of your favorite ESP8266 board Connect GND to GND of WS2812B and ESP device Connect GPIO3/RX pin of ESP8266 to WS2812B Attach at least a 1000μF capacitor between 5V and GND near the first LED  ","permalink":"https://www.debashishsahu.com/posts/esp8266-esp32-based-rgb-light-neopixels-connecting-to-google-home-alexa-via-artik-cloud/","summary":"⚠️ ⚠️ ⚠️ ARTIK Cloud has been depcreciated by Samsung ⚠️ ⚠️ ⚠️ Here we create an ESP8266/32 based device that emulates a RGB LED light using NeoPixels, which connects to ATRIK cloud. ARTIK cloud connects to smart home assistants like Google Home, Amazon Alexa, etc.\nConnecting to Samsung ARTIK Cloud https://my.artik.cloud/\nGitHub: debsahu/ARTIKCloud An application made for ESP8266 to comunicate with ARTIK Cloud\n Connects to ARTIK Cloud via MQTT SSL port 8883 ARTIK Cloud is connected to all assistant platforms, integration is seamless Compiles on ESP8266-arduino core v2.","title":"ESP8266/ESP32 Based RGB Light (NeoPixels) Connecting to Google Home \u0026 Alexa via ARTIK Cloud"},{"content":"    Here we attempt to use Linux on Windows.\nWSL on Windows: https://aka.ms/wslinstall\nCanonical Multipass: https://github.com/CanonicalLtd/multipass\n","permalink":"https://www.debashishsahu.com/posts/linux-on-windows-10/","summary":"Here we attempt to use Linux on Windows.\nWSL on Windows: https://aka.ms/wslinstall\nCanonical Multipass: https://github.com/CanonicalLtd/multipass","title":"Linux on Windows 10"},{"content":"    The goal here is to control a \u0026ldquo;dumb\u0026rdquo; TV using virtual assistants via Home Assistant. We tap into the push button of the TV and use a transistor along with ESP8266 to mimic a button press.\nGitHub: debsahu/PegasusTV Goal:  Control a \u0026ldquo;dumb\u0026rdquo; TV using virtual assistants via Home Assistant  Features:  Uses D2 to control 2N2222 transistor Control using Web and MQTT API Completely Async WiFiManager Captive Portal to get WiFi credentials (Compile with -DUSE_EADNS for ESP8266) Connect PIN_CTRL pin to base of 2N2222, collector to Probe and emitter to GND  Hardware Software Overview Libraries Needed platformio.ini is included, use PlatformIO and it will take care of installing the following libraries.\n   Library Link     ESPAsyncUDP https://github.com/me-no-dev/ESPAsyncUDP   ESPAsyncTCP https://github.com/me-no-dev/ESPAsyncTCP   ESPAsyncWiFiManager https://github.com/alanswx/ESPAsyncWiFiManager   ESPAsyncDNSServer https://github.com/devyte/ESPAsyncDNSServer   ESP Async WebServer https://github.com/me-no-dev/ESPAsyncWebServer   AsyncMqttClient https://github.com/marvinroger/async-mqtt-client    ","permalink":"https://www.debashishsahu.com/posts/control-a-dumb-tv-using-a-transistor-and-esp8266/","summary":"The goal here is to control a \u0026ldquo;dumb\u0026rdquo; TV using virtual assistants via Home Assistant. We tap into the push button of the TV and use a transistor along with ESP8266 to mimic a button press.\nGitHub: debsahu/PegasusTV Goal:  Control a \u0026ldquo;dumb\u0026rdquo; TV using virtual assistants via Home Assistant  Features:  Uses D2 to control 2N2222 transistor Control using Web and MQTT API Completely Async WiFiManager Captive Portal to get WiFi credentials (Compile with -DUSE_EADNS for ESP8266) Connect PIN_CTRL pin to base of 2N2222, collector to Probe and emitter to GND  Hardware Software Overview Libraries Needed platformio.","title":"Control a \"Dumb\" TV Using a Transistor and ESP8266"},{"content":"     Exploiting low light photography with long exposure to paint in thin air using NeoPixels LED strips. Here we send real-time data using the E1.31 sACN protocol to a ESP8266 code: https://github.com/debsahu/E131_PixelPusher that displays strips of pictures over time. These bright lights are registered on the sensors of camera yielding out of the world photos!  ","permalink":"https://www.debashishsahu.com/posts/neopixel-painter-draw-using-leds-on-thin-air/","summary":"     Exploiting low light photography with long exposure to paint in thin air using NeoPixels LED strips. Here we send real-time data using the E1.31 sACN protocol to a ESP8266 code: https://github.com/debsahu/E131_PixelPusher that displays strips of pictures over time. These bright lights are registered on the sensors of camera yielding out of the world photos!  ","title":"NeoPixel Painter Draw Using LEDs on Thin Air"},{"content":"    Here we try to push E1.31 UDP data received wirelessly via ESP8266 and pushed to NeoPixel in the fastest way possible.\nOther projects with E1.31 support:\n GitHub: forkineye/ESPixelStick GitHub: Aircoookie/WLED GitHub: toblum/McLighting  I also demonstrate how to setup and use Jinx!, ledfx and xLights\nGitHub: debsahu/E131_PixelPusher Minimalistic Async code around Async E131 for ESP8266/ESP32\n Completely Async Web-interface to set starting universe, unicast/umulticast, total number of universes WiFiManager Captive Portal to get WiFi credentials (Compile with -DUSE_EADNS for ESP8266) Subscribes to E131 multicast Connect RX/GPIO3 to DIN of NeoPixel strip, and any PIN (\u0026lt;GPIO32) specified for ESP32 Upload included firmware.bin at http://\u0026lt;IP_ADDRESS\u0026gt;/update for ESP8266, compile your own for ESP32 Included relavent lines for APA102/Dotstar LED strip: Comment //#define USE_NEOPIXELS xxx and uncomment #define USE_DOTSTAR  ESP8266 Hardware SPI: Uses GPIO14(SCK) for CLOCK and GPIO13(MOSI) for DATA ESP32 Hardware SPI: Uses GPIO18(SCK) for CLOCK and GPIO23(MOSI) for DATA    Libraries Needed platformio.ini is included, use PlatformIO and it will take care of installing the following libraries.\n   Library Link Platform     ESPAsyncE131 https://github.com/forkineye/ESPAsyncE131 ESP8266/32   ESPAsyncUDP https://github.com/me-no-dev/ESPAsyncUDP ESP8266   ESPAsyncTCP https://github.com/me-no-dev/ESPAsyncTCP ESP8266   NeoPixelBus https://github.com/Makuna/NeoPixelBus ESP8266/32   ESPAsyncWiFiManager https://github.com/alanswx/ESPAsyncWiFiManager ESP8266/32   ESPAsyncDNSServer https://github.com/devyte/ESPAsyncDNSServer ESP8266   ESP Async WebServer https://github.com/me-no-dev/ESPAsyncWebServer ESP8266/32   AsyncTCP https://github.com/me-no-dev/AsyncTCP ESP32   Adafruit\u0026rsquo;s Dot Star https://github.com/debsahu/Adafruit_DotStar ESP8266/32    Pushing E1.31 UDP Data Jinx  Download Jinx from here Setup instructions: see video  LEDfx  Download and installation instructions for LEDfx are here Setup instructions: see video  xLights  Download xLights from here Setup instructions: see video  ","permalink":"https://www.debashishsahu.com/posts/e1-31-pixel-pusher-sending-e1-31-udp-data-to-esp8266-displayed-on-neopixels/","summary":"Here we try to push E1.31 UDP data received wirelessly via ESP8266 and pushed to NeoPixel in the fastest way possible.\nOther projects with E1.31 support:\n GitHub: forkineye/ESPixelStick GitHub: Aircoookie/WLED GitHub: toblum/McLighting  I also demonstrate how to setup and use Jinx!, ledfx and xLights\nGitHub: debsahu/E131_PixelPusher Minimalistic Async code around Async E131 for ESP8266/ESP32\n Completely Async Web-interface to set starting universe, unicast/umulticast, total number of universes WiFiManager Captive Portal to get WiFi credentials (Compile with -DUSE_EADNS for ESP8266) Subscribes to E131 multicast Connect RX/GPIO3 to DIN of NeoPixel strip, and any PIN (\u0026lt;GPIO32) specified for ESP32 Upload included firmware.","title":"E1.31 Pixel Pusher: Sending E1.31 UDP Data to ESP8266 Displayed on NeoPixels"},{"content":"    Here is a demonstration of using lxml for scraping a website to extract essential HTML data and pass the data as sensor to Home Assistant.\nGitHub: debsahu/lxmlWebScraper Here is a demonstration of using lxml for scraping a website to extract essential HTML data and pass the data as sensor to Home Assistant.\nOverview Installing lxml If working in virtual environment, install lxml using pip\n$ pip3 install lxml If working on python installation installed globally\n$ sudo apt-get install python3-lxml Home Assistant Sensor ","permalink":"https://www.debashishsahu.com/posts/creating-a-home-assistant-web-scraper-sensor/","summary":"Here is a demonstration of using lxml for scraping a website to extract essential HTML data and pass the data as sensor to Home Assistant.\nGitHub: debsahu/lxmlWebScraper Here is a demonstration of using lxml for scraping a website to extract essential HTML data and pass the data as sensor to Home Assistant.\nOverview Installing lxml If working in virtual environment, install lxml using pip\n$ pip3 install lxml If working on python installation installed globally","title":"Creating a Home Assistant Web Scraper Sensor"},{"content":"    Demonstration on ESP8266 \u0026amp; ESP32 using SSL/TLSv1.2 two-way handshake with secured mosquitto broker. SSL is preferred way of encryption of communication between devices over the internet. Here we secure a mosquitto MQTT broker and connect to it via ESP8266 \u0026amp; ESP32 that do a two-way handshake.\nAndreas Spiess on ESP devices \u0026amp; SSL: https://www.youtube.com/watch?v=Wm1xKj4bKsY\nGitHub: debsahu/ESP_MQTT_Secure ⚠️ ⚠️ ⚠️ Will not be maintained/updated ⚠️ ⚠️ ⚠️\nDemonstration on ESP8266 \u0026amp; ESP32 using SSL/TLSv1.2 two-way handshake with secured mosquitto broker.\nDependencies Listed below are the dpendencies used by Arduino IDE, but use PlatformioIO instead!\n   Library Link Use     PubSubClient https://github.com/knolleary/pubsubclient mqtt comm impl   MQTT https://github.com/256dpi/arduino-mqtt mqtt comm impl    Installing mosquitto on RPi (Stretch) as of Nov 16th 2018 See video to find out the steps to obtain ca.crt, raspberrypi.crt, raspberry.key\n$ sudo apt-get update $ sudo apt-get install -y mosquitto mosquitto-clients $ sudo systemctl enable mosquitto.service $ sudo cp ca.crt /etc/mosquitto/certs $ sudo cp raspberrypi.crt /etc/mosquitto/certs $ sudo cp raspberrypi.key /etc/mosquitto/certs $ sudo chown mosquito: /etc/mosquitto/certs $ sudo mosquitto_passwd -c /etc/mosquitto/passwd miot Add following lines to bottom of /etc/mosquitto/mosquitto.conf\nallow_anonymous false password_file /etc/mosquitto/passwd listener 1883 127.0.0.1 listener 8883 cafile /etc/mosquitto/certs/ca.crt certfile /etc/mosquitto/certs/raspberrypi.crt keyfile /etc/mosquitto/certs/raspberrypi.key require_certificate false listener 9883 protocol websockets cafile /etc/mosquitto/certs/ca.crt certfile /etc/mosquitto/certs/raspberrypi.crt keyfile /etc/mosquitto/certs/raspberrypi.key require_certificate false After updating mosquitto.conf, start the mosquitto server\n$ sudo systemctl start mosquitto.service Remember to forward ports 8883 and 9883 to the internet!\n","permalink":"https://www.debashishsahu.com/posts/esp8266-esp32-connecting-to-ssl-tlsv1-2-secured-mosquitto-mqtt-broker/","summary":"Demonstration on ESP8266 \u0026amp; ESP32 using SSL/TLSv1.2 two-way handshake with secured mosquitto broker. SSL is preferred way of encryption of communication between devices over the internet. Here we secure a mosquitto MQTT broker and connect to it via ESP8266 \u0026amp; ESP32 that do a two-way handshake.\nAndreas Spiess on ESP devices \u0026amp; SSL: https://www.youtube.com/watch?v=Wm1xKj4bKsY\nGitHub: debsahu/ESP_MQTT_Secure ⚠️ ⚠️ ⚠️ Will not be maintained/updated ⚠️ ⚠️ ⚠️","title":"ESP8266/ESP32 Connecting to SSL/TLSv1.2 Secured Mosquitto MQTT Broker"},{"content":"    Here is a tutorial on how to call RESTful API on ESP8266 and process the data using ArduinoJSON. This data is visually represented in a NeoPixel ring for easy tracking of 3 buses approaching a certain stop. This code also sends MQTT messages with the received data.\ndebsahu/RESTful-Ride Using ESP8266 to call RESTful API from http://TheRide.org to get real-time BUS data\nFeatures:  Easy to read interface Fast and Responsive Portable, i.e. small Wireless MQTT $$$ Cheap $$$  Hardware  NodeMCU (ESP8266) NeoPixel Ring (16 LEDs)  Software  Developer API key from TheRide.org PlatformIO MQTT Server Home Assistant  Wiring Connect:\n VCC of NeoPixel to 5V/Vin of NodeMCU GND of NeoPIxel to GND of NodeMCU Data in of NeoPIxel to RX pin of NodeMCU via 100-500Ohm resistor  ","permalink":"https://www.debashishsahu.com/posts/using-esp8266-to-call-restful-api-from-theride-to-get-real-time-bus-data/","summary":"Here is a tutorial on how to call RESTful API on ESP8266 and process the data using ArduinoJSON. This data is visually represented in a NeoPixel ring for easy tracking of 3 buses approaching a certain stop. This code also sends MQTT messages with the received data.\ndebsahu/RESTful-Ride Using ESP8266 to call RESTful API from http://TheRide.org to get real-time BUS data\nFeatures:  Easy to read interface Fast and Responsive Portable, i.","title":"Using ESP8266 to Call RESTful API From TheRide to Get Real-Time BUS Data"},{"content":"    Idea To convert an automatic trash can into a smart one.\nHardware  Automatic Trash Can Wemos D1 mini (ESP8266) 2N2222 transistor  Implementation Here we use an ESP8266 to tap into the pins and emulate a physical button press. The ESP8266 uses a code as described in https://github.com/debsahu/SmartTrashCan to emulate a Wemo Switch, which is detected by Alexa/Echo device as a switch.\nGitHub: debsahu/SmartTrashCan Dependencies    Library Link Use     Wemo Switch Emulator Library https://github.com/witnessmenow/esp8266-alexa-wemo-emulator comm    AlexaDustbin.ino\n#include \u0026lt;ESP8266WiFi.h\u0026gt; #include \u0026lt;ESP8266mDNS.h\u0026gt; #include \u0026lt;WiFiUdp.h\u0026gt; #include \u0026lt;ArduinoOTA.h\u0026gt; #include \u0026lt;Ticker.h\u0026gt; #include \u0026lt;WemoSwitch.h\u0026gt; // https://github.com/witnessmenow/esp8266-alexa-wemo-emulator #include \u0026lt;WemoManager.h\u0026gt; #include \u0026lt;CallbackFunction.h\u0026gt; //#include \u0026quot;secret.h\u0026quot; #include \u0026quot;version.h\u0026quot; #define HOSTNAME \u0026quot;Trash can\u0026quot; #ifndef SECRET const char* ssid = \u0026quot;\u0026lt;WiFiSSID\u0026gt;\u0026quot;; const char* password = \u0026quot;\u0026lt;WiFiPassword\u0026gt;\u0026quot;; const char* otapassword = \u0026quot;\u0026lt;ArduinoOTAPassword\u0026gt;\u0026quot;; #endif const int OffPin = D2; const int OnPin = D5; float timerDelay = 15.0; // (s) delay for autoclose after opening ///////////////////////////////////////////// WemoManager wemoManager; WemoSwitch *light = NULL; Ticker baseOff; Ticker autoTimer; void bothOff() { digitalWrite(OffPin, LOW); digitalWrite(OnPin, LOW); baseOff.detach(); } void lightOn() { Serial.print(\u0026quot;Open Lid ...\u0026quot;); digitalWrite(OnPin, HIGH); baseOff.attach(0.05, bothOff); autoTimer.attach(timerDelay, lightOff); } void lightOff() { Serial.print(\u0026quot;Close Lid ...\u0026quot;); digitalWrite(OffPin, HIGH); baseOff.attach(0.05, bothOff); autoTimer.detach(); } void setup() { Serial.begin(115200); // Set WiFi to station mode and disconnect from an AP if it was Previously // connected WiFi.mode(WIFI_STA); WiFi.disconnect(); delay(100); // Attempt to connect to Wifi network: Serial.print(\u0026quot;Connecting Wifi: \u0026quot;); Serial.println(ssid); WiFi.begin(ssid, password); while (WiFi.waitForConnectResult() != WL_CONNECTED) { Serial.println(\u0026quot;Connection Failed! Rebooting...\u0026quot;); delay(5000); ESP.restart(); } ArduinoOTA.setHostname(HOSTNAME); ArduinoOTA.setPassword(otapassword); ArduinoOTA.onStart([]() { String type; if (ArduinoOTA.getCommand() == U_FLASH) { type = \u0026quot;sketch\u0026quot;; } else { // U_SPIFFS type = \u0026quot;filesystem\u0026quot;; } Serial.println(\u0026quot;Start updating \u0026quot; + type); }); ArduinoOTA.onEnd([]() { Serial.println(\u0026quot;\\nEnd\u0026quot;); }); ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) { Serial.printf(\u0026quot;Progress: %u%%\\r\u0026quot;, (progress / (total / 100))); }); ArduinoOTA.onError([](ota_error_t error) { Serial.printf(\u0026quot;Error[%u]: \u0026quot;, error); if (error == OTA_AUTH_ERROR) { Serial.println(\u0026quot;Auth Failed\u0026quot;); } else if (error == OTA_BEGIN_ERROR) { Serial.println(\u0026quot;Begin Failed\u0026quot;); } else if (error == OTA_CONNECT_ERROR) { Serial.println(\u0026quot;Connect Failed\u0026quot;); } else if (error == OTA_RECEIVE_ERROR) { Serial.println(\u0026quot;Receive Failed\u0026quot;); } else if (error == OTA_END_ERROR) { Serial.println(\u0026quot;End Failed\u0026quot;); } }); ArduinoOTA.begin(); Serial.println(\u0026quot;\u0026quot;); Serial.println(\u0026quot;WiFi connected\u0026quot;); Serial.println(\u0026quot;IP address: \u0026quot;); IPAddress ip = WiFi.localIP(); Serial.println(ip); wemoManager.begin(); // Format: Alexa invocation name, local port no, on callback, off callback light = new WemoSwitch(HOSTNAME, 80, lightOn, lightOff); wemoManager.addDevice(*light); pinMode(OffPin, OUTPUT); pinMode(OnPin, OUTPUT); bothOff(); } void loop() { ArduinoOTA.handle(); wemoManager.serverLoop(); } ","permalink":"https://www.debashishsahu.com/posts/hacking-an-automatic-trash-can-to-listen-to-you/","summary":"Idea To convert an automatic trash can into a smart one.\nHardware  Automatic Trash Can Wemos D1 mini (ESP8266) 2N2222 transistor  Implementation Here we use an ESP8266 to tap into the pins and emulate a physical button press. The ESP8266 uses a code as described in https://github.com/debsahu/SmartTrashCan to emulate a Wemo Switch, which is detected by Alexa/Echo device as a switch.\nGitHub: debsahu/SmartTrashCan Dependencies    Library Link Use     Wemo Switch Emulator Library https://github.","title":"Hacking an Automatic Trash Can to Listen to You"},{"content":"    Getting one\u0026rsquo;s hands on APDS9960 is very easy, that can be used to detect hand gestures. Here we use this sensor to control lights on Home Assistant based on a gesture observed on sensor.\nSoftware Libraries used:  HARestAPI GitHub: debsahu/HARestAPI APDS9960 GitHub: SteveQuinn1/SparkFun_APDS-9960_Sensor_Arduino_Library SSD1306 OLED I2C GitHub: ThingPulse/esp8266-oled-ssd1306   ","permalink":"https://www.debashishsahu.com/posts/using-gestures-to-control-lights-on-home-assistant/","summary":"    Getting one\u0026rsquo;s hands on APDS9960 is very easy, that can be used to detect hand gestures. Here we use this sensor to control lights on Home Assistant based on a gesture observed on sensor.\nSoftware Libraries used:  HARestAPI GitHub: debsahu/HARestAPI APDS9960 GitHub: SteveQuinn1/SparkFun_APDS-9960_Sensor_Arduino_Library SSD1306 OLED I2C GitHub: ThingPulse/esp8266-oled-ssd1306   ","title":"Using Gestures to Control Lights on Home-Assistant"},{"content":"    Arduino library connecting to the AWS IoT service from an ESP8266 using websockets and MQTT.\nGitHub: debsahu/esp8266-arduino-aws-iot-ws ⚠️ ⚠️ ⚠️ This is no longer maintained and obsolete, there is better way to do this: follow instructions from here Still want to use this, follow instructions below ⚠️ ⚠️ ⚠️ Arduino Library derived from joekickass/esp8266-arduino-aws-iot-ws to work with Arduino\nDependencies    Library Link Use     arduinoWebSockets https://github.com/Links2004/arduinoWebSockets websocket comm impl   PahoMQTT https://projects.eclipse.org/projects/technology.paho/downloads mqtt comm impl   ArduinoJSON 6.5.0-beta https://github.com/bblanchon/ArduinoJson/releases data    Headers from joekickass/esp8266-arduino-aws-iot-ws Library for connecting to the AWS IoT service from an ESP8266 using websockets. Authenticates using AWS IAM credentials and sigV4.\nBased on the work of AWS labs, basically using its SigV4 implementation and a fork by Sander van de Graaf. The fork is reflected in the License.\nInspired by Fábio Toledos work on aws-mqtt-websockets, but using libraries accessible through the PlatformIO library manager. This is actually the main reason for creating the library.\nAdds MQTT functionality using the Paho library. It is fairly easy to replace with another MQTT client, e.g. PubSubClient.\nAttributions Big thanks to Fábio Toledo for his work on aws-mqtt-websockets. Any credit should be directed to him and the authors of the libraries used in this project.\nThe library uses code from the following projects. License information can be found in the NOTICE file:\n AWS labs - aws-sdk-arduino Sander van de Graaf - aws-sdk-arduino Fábio Toledo - aws-mqtt-websockets Serge Zaitsev - JSMN Paho MQTT client Stephan Brumme - SHA256  In the case of missing license information, I took the liberty of adding it.\n","permalink":"https://www.debashishsahu.com/posts/esp8266-talking-to-aws-iot-using-mqtt/","summary":"Arduino library connecting to the AWS IoT service from an ESP8266 using websockets and MQTT.\nGitHub: debsahu/esp8266-arduino-aws-iot-ws ⚠️ ⚠️ ⚠️ This is no longer maintained and obsolete, there is better way to do this: follow instructions from here Still want to use this, follow instructions below ⚠️ ⚠️ ⚠️ Arduino Library derived from joekickass/esp8266-arduino-aws-iot-ws to work with Arduino\nDependencies    Library Link Use     arduinoWebSockets https://github.","title":"ESP8266 Talking to AWS IoT Using MQTT"},{"content":"    Using esp8266-google-home-notifier library on ESP8266 to make Google Home speak!\nSoftware Prerequisites/Limitations  The GoogleHomeName must match the name of Google Home / mini setup in Google Home App. The ESP8266 must be on the same network as Google Home. MDNS: Dont include ESP8266mDNS.h supplied by Arduino-ESP8266. Internal ESP8266mDNS.h should suffice.  Libraries required  esp8266-google-home-notifier esp8266-google-tts WiFiManager (optional)  GitHub: debsahu/GoogleSay sercret.h\n#define SECRET const char* ssid = \u0026quot;\u0026lt;WiFiSSID\u0026gt;\u0026quot;; const char* password = \u0026quot;\u0026lt;WiFiPassword\u0026gt;\u0026quot;; GoogleSay.ino\n#include \u0026lt;ESP8266WiFi.h\u0026gt; #include \u0026lt;WiFiClient.h\u0026gt; #include \u0026lt;ESP8266WebServer.h\u0026gt; #include \u0026lt;esp8266-google-home-notifier.h\u0026gt; //https://github.com/horihiro/esp8266-google-home-notifier //https://github.com/horihiro/esp8266-google-tts //#include \u0026quot;secret.h\u0026quot; #include \u0026quot;version.h\u0026quot; #define USE_WIFIMANAGER #ifdef USE_WIFIMANAGER #include \u0026lt;WiFiManager.h\u0026gt; //https://github.com/tzapu/WiFiManager #else #ifndef SECRET const char* ssid = \u0026quot;\u0026lt;WiFiSSID\u0026gt;\u0026quot;; const char* password = \u0026quot;\u0026lt;WiFiPassword\u0026gt;\u0026quot;; #endif #endif const char GoogleHomeName[] = \u0026quot;Living Room speaker\u0026quot;; //Must match the name on Google Home APP const char *host= \u0026quot;GoogleSay\u0026quot;; String ttstext = \u0026quot;Welcome to Esp8266 TTS\u0026quot;; ESP8266WebServer server(80); GoogleHomeNotifier ghn; void handleRoot() { String webpage; webpage = \u0026quot;\u0026lt;html\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;meta name='viewport' content='width=device-width,initial-scale=1' /\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Make Google Home Speak\u0026lt;/title\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;style\u0026gt;\u0026quot;; webpage += \u0026quot;body { background-color: #E6E6FA; font-family: Arial, Helvetica, Sans-Serif; Color: blue;}\u0026quot;; webpage += \u0026quot;\u0026lt;/style\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;/head\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;body\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;br\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;form action='/processspeak' method='POST'\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;center\u0026gt;\u0026lt;input type='text' name='search_input' value='\u0026quot; + ttstext + \u0026quot;' placeholder='Google Home Text' size='75' style='text-align:center;'\u0026gt;\u0026lt;/center\u0026gt;\u0026lt;br\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;center\u0026gt;\u0026lt;input type='submit' value='Speak!'\u0026gt;\u0026lt;/center\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;/form\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;/body\u0026gt;\u0026quot;; webpage += \u0026quot;\u0026lt;/html\u0026gt;\u0026quot;; server.send(200, \u0026quot;text/html\u0026quot;, webpage); // Send a response to the client asking for input } void processSpeak(){ if (server.args() \u0026gt; 0 and server.method() == HTTP_POST) { // Arguments were received for ( uint8_t i = 0; i \u0026lt; server.args(); i++ ) { Serial.print(server.argName(i)); // Display the argument if (server.argName(i) == \u0026quot;search_input\u0026quot;) { Serial.print(\u0026quot; : \u0026quot;); Serial.println(server.arg(i)); ttstext=server.arg(i); if (ghn.notify(ttstext.c_str()) != true) { Serial.println(ghn.getLastError()); return; } } } } String t; t += \u0026quot;\u0026lt;html\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;head\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;meta name='viewport' content='width=device-width,initial-scale=1' /\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;meta http-equiv='Content-Type' content='text/html; charset=utf-8' /\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;meta http-equiv='refresh' content='3;url=/'/\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;/head\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;body\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;center\u0026gt;\u0026lt;p\u0026gt;Saying: \u0026quot; + ttstext + \u0026quot;\u0026lt;/p\u0026gt;\u0026lt;/center\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;br\u0026gt;\u0026lt;center\u0026gt;\u0026lt;a href='/'\u0026gt;Update again?\u0026lt;/a\u0026gt;\u0026lt;/center\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;/form\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;/body\u0026gt;\u0026quot;; t += \u0026quot;\u0026lt;/html\u0026gt;\u0026quot;; server.send(200, \u0026quot;text/html\u0026quot;, t); } void handleNotFound() { String message = \u0026quot;File Not Found\\n\\n\u0026quot;; message += \u0026quot;URI: \u0026quot;; message += server.uri(); message += \u0026quot;\\nMethod: \u0026quot;; message += (server.method() == HTTP_GET) ? \u0026quot;GET\u0026quot; : \u0026quot;POST\u0026quot;; message += \u0026quot;\\nArguments: \u0026quot;; message += server.args(); message += \u0026quot;\\n\u0026quot;; for (uint8_t i = 0; i \u0026lt; server.args(); i++) { message += \u0026quot; \u0026quot; + server.argName(i) + \u0026quot;: \u0026quot; + server.arg(i) + \u0026quot;\\n\u0026quot;; } server.send(404, \u0026quot;text/plain\u0026quot;, message); } void connectToGH(){ Serial.println(\u0026quot;connecting to Google Home...\u0026quot;); if (ghn.device(GoogleHomeName, \u0026quot;en\u0026quot;) != true) { Serial.println(ghn.getLastError()); return; } Serial.print(\u0026quot;found Google Home(\u0026quot;); Serial.print(ghn.getIPAddress()); Serial.print(\u0026quot;:\u0026quot;); Serial.print(ghn.getPort()); Serial.println(\u0026quot;)\u0026quot;); } #ifndef USE_WIFIMANAGER void connectWiFiConfig(void) { Serial.println(\u0026quot;\\n\u0026quot;); Serial.print(\u0026quot;Connecting to \u0026quot;); Serial.print(ssid); WiFi.begin(ssid, password); int wifi_loops=0, wifi_timeout = WIFI_TIMEOUT_DEF; while (WiFi.status() != WL_CONNECTED) { wifi_loops++; Serial.print(\u0026quot;.\u0026quot;); delay(500); if (wifi_loops\u0026gt;wifi_timeout) software_reset(); } Serial.println(\u0026quot;connected\u0026quot;); Serial.print(\u0026quot;IP address: \u0026quot;); Serial.println(WiFi.localIP()); } #else void connectWiFiManager() { WiFiManager wifiManager; wifiManager.setDebugOutput(true); wifiManager.setTimeout(180); if (!wifiManager.autoConnect(const_cast\u0026lt;char*\u0026gt;(host))) { Serial.println(\u0026quot;failed to connect and hit timeout\u0026quot;); delay(3000); //reset and try again, or maybe put it to deep sleep ESP.restart(); delay(5000); } Serial.println(\u0026quot;connected.\u0026quot;); Serial.print(\u0026quot;IP address: \u0026quot;); Serial.println(WiFi.localIP()); } void resetWlan(){ Serial.printf(\u0026quot;/reset_wlan\\n\u0026quot;); server.send(200, \u0026quot;text/plain\u0026quot;, \u0026quot;Resetting WLAN and restarting...\u0026quot; ); WiFiManager wifiManager; wifiManager.resetSettings(); ESP.restart(); } #endif String ipToString(IPAddress ip){ String s=\u0026quot;http:// \u0026quot;; for (int i=0; i\u0026lt;4; i++) s += i ? \u0026quot; dot \u0026quot; + String(ip[i]) : String(ip[i]); return s; } void setup(void) { Serial.begin(115200); WiFi.mode(WIFI_STA); #ifndef USE_WIFIMANAGER connectWiFiConfig(); // Connect to WiFi #else connectWiFiManager(); // Connect to WiFi #endif server.on(\u0026quot;/\u0026quot;, handleRoot); server.on(\u0026quot;/processspeak\u0026quot;, processSpeak); #ifdef USE_WIFIMANAGER server.on(\u0026quot;/reset_wlan\u0026quot;, resetWlan); #endif server.on(\u0026quot;/version\u0026quot;, [](){ String replyjson = \u0026quot;{\\\u0026quot;version\\\u0026quot;:\\\u0026quot;\u0026quot; + String(SKETCH_VERSION) + \u0026quot;\\\u0026quot;}\u0026quot;; server.send(200, \u0026quot;application/json\u0026quot;, replyjson); }); server.onNotFound(handleNotFound); server.begin(); Serial.println(\u0026quot;HTTP server started\u0026quot;); if (MDNS.begin(host)) { Serial.println(\u0026quot;MDNS responder started\u0026quot;); } connectToGH(); String init_text = \u0026quot;Goto \u0026quot; + ipToString(WiFi.localIP()) + \u0026quot; on your web browser to make me speak!\u0026quot;; if (ghn.notify(init_text.c_str()) != true) { Serial.println(ghn.getLastError()); return; } Serial.println(\u0026quot;Done.\u0026quot;); } void loop(void) { server.handleClient(); } ","permalink":"https://www.debashishsahu.com/posts/esp8266-making-google-home-speak/","summary":"Using esp8266-google-home-notifier library on ESP8266 to make Google Home speak!\nSoftware Prerequisites/Limitations  The GoogleHomeName must match the name of Google Home / mini setup in Google Home App. The ESP8266 must be on the same network as Google Home. MDNS: Dont include ESP8266mDNS.h supplied by Arduino-ESP8266. Internal ESP8266mDNS.h should suffice.  Libraries required  esp8266-google-home-notifier esp8266-google-tts WiFiManager (optional)  GitHub: debsahu/GoogleSay sercret.h\n#define SECRET const char* ssid = \u0026quot;\u0026lt;WiFiSSID\u0026gt;\u0026quot;; const char* password = \u0026quot;\u0026lt;WiFiPassword\u0026gt;\u0026quot;; GoogleSay.","title":"ESP8266 Making Google Home Speak"},{"content":"    Using ESP32 to communicate with Xiaomi flora (miflora) plant sensor using BLE and posting the values on MQTT server. I also demonstrate the use of Home Assistant miflora sensor component.\nChange ESP32 Partition: https://desire.giesecke.tk/index.php/2018/04/20/change-partition-size-arduino-ide/ Home Assistant miflora sensor: https://www.home-assistant.io/components/sensor.miflora/\nGitHub: sidddy/flora Archived code from https://github.com/sidddy/flora below\nconfig.h\n// array of different xiaomi flora MAC addresses char* FLORA_DEVICES[] = { \u0026quot;C4:7C:8D:67:11:11\u0026quot;, \u0026quot;C4:7C:8D:67:22:22\u0026quot;, \u0026quot;C4:7C:8D:67:33:33\u0026quot; }; // sleep between to runs in seconds #define SLEEP_DURATION 30 * 60 // emergency hibernate countdown in seconds #define EMERGENCY_HIBERNATE 3 * 60 // how often should the battery be read - in run count #define BATTERY_INTERVAL 6 // how often should a device be retried in a run when something fails #define RETRY 3 const char* WIFI_SSID = \u0026quot;ssid\u0026quot;; const char* WIFI_PASSWORD = \u0026quot;password\u0026quot;; // MQTT topic gets defined by \u0026quot;\u0026lt;MQTT_BASE_TOPIC\u0026gt;/\u0026lt;MAC_ADDRESS\u0026gt;/\u0026lt;property\u0026gt;\u0026quot; // where MAC_ADDRESS is one of the values from FLORA_DEVICES array // property is either temperature, moisture, conductivity, light or battery const char* MQTT_HOST = \u0026quot;10.10.10.1\u0026quot;; const int MQTT_PORT = 1883; const char* MQTT_CLIENTID = \u0026quot;miflora-client\u0026quot;; const char* MQTT_USERNAME = \u0026quot;username\u0026quot;; const char* MQTT_PASSWORD = \u0026quot;password\u0026quot;; const String MQTT_BASE_TOPIC = \u0026quot;flora\u0026quot;; const int MQTT_RETRY_WAIT = 5000; flora.ino\n/** A BLE client for the Xiaomi Mi Plant Sensor, pushing measurements to an MQTT server. See https://github.com/nkolban/esp32-snippets/blob/master/Documentation/BLE%20C%2B%2B%20Guide.pdf on how bluetooth low energy and the library used are working. See https://github.com/ChrisScheffler/miflora/wiki/The-Basics for details on how the protocol is working. MIT License Copyright (c) 2017 Sven Henkel Multiple units reading by Grega Lebar 2018 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u0026quot;Software\u0026quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u0026quot;AS IS\u0026quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ #include \u0026quot;BLEDevice.h\u0026quot; #include \u0026lt;WiFi.h\u0026gt; #include \u0026lt;PubSubClient.h\u0026gt; #include \u0026quot;config.h\u0026quot; // boot count used to check if battery status should be read RTC_DATA_ATTR int bootCount = 0; // device count static int deviceCount = sizeof FLORA_DEVICES / sizeof FLORA_DEVICES[0]; // the remote service we wish to connect to static BLEUUID serviceUUID(\u0026quot;00001204-0000-1000-8000-00805f9b34fb\u0026quot;); // the characteristic of the remote service we are interested in static BLEUUID uuid_version_battery(\u0026quot;00001a02-0000-1000-8000-00805f9b34fb\u0026quot;); static BLEUUID uuid_sensor_data(\u0026quot;00001a01-0000-1000-8000-00805f9b34fb\u0026quot;); static BLEUUID uuid_write_mode(\u0026quot;00001a00-0000-1000-8000-00805f9b34fb\u0026quot;); TaskHandle_t hibernateTaskHandle = NULL; WiFiClient espClient; PubSubClient client(espClient); void connectWifi() { Serial.println(\u0026quot;Connecting to WiFi...\u0026quot;); WiFi.begin(WIFI_SSID, WIFI_PASSWORD); while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print(\u0026quot;.\u0026quot;); } Serial.println(\u0026quot;\u0026quot;); Serial.println(\u0026quot;WiFi connected\u0026quot;); Serial.println(\u0026quot;\u0026quot;); } void disconnectWifi() { WiFi.disconnect(true); Serial.println(\u0026quot;WiFi disonnected\u0026quot;); } void connectMqtt() { Serial.println(\u0026quot;Connecting to MQTT...\u0026quot;); client.setServer(MQTT_HOST, MQTT_PORT); while (!client.connected()) { if (!client.connect(MQTT_CLIENTID, MQTT_USERNAME, MQTT_PASSWORD)) { Serial.print(\u0026quot;MQTT connection failed:\u0026quot;); Serial.print(client.state()); Serial.println(\u0026quot;Retrying...\u0026quot;); delay(MQTT_RETRY_WAIT); } } Serial.println(\u0026quot;MQTT connected\u0026quot;); Serial.println(\u0026quot;\u0026quot;); } void disconnectMqtt() { client.disconnect(); Serial.println(\u0026quot;MQTT disconnected\u0026quot;); } BLEClient* getFloraClient(BLEAddress floraAddress) { BLEClient* floraClient = BLEDevice::createClient(); if (!floraClient-\u0026gt;connect(floraAddress)) { Serial.println(\u0026quot;- Connection failed, skipping\u0026quot;); return nullptr; } Serial.println(\u0026quot;- Connection successful\u0026quot;); return floraClient; } BLERemoteService* getFloraService(BLEClient* floraClient) { BLERemoteService* floraService = nullptr; try { floraService = floraClient-\u0026gt;getService(serviceUUID); } catch (...) { // something went wrong } if (floraService == nullptr) { Serial.println(\u0026quot;- Failed to find data service\u0026quot;); } else { Serial.println(\u0026quot;- Found data service\u0026quot;); } return floraService; } bool forceFloraServiceDataMode(BLERemoteService* floraService) { BLERemoteCharacteristic* floraCharacteristic; // get device mode characteristic, needs to be changed to read data Serial.println(\u0026quot;- Force device in data mode\u0026quot;); floraCharacteristic = nullptr; try { floraCharacteristic = floraService-\u0026gt;getCharacteristic(uuid_write_mode); } catch (...) { // something went wrong } if (floraCharacteristic == nullptr) { Serial.println(\u0026quot;-- Failed, skipping device\u0026quot;); return false; } // write the magic data uint8_t buf[2] = {0xA0, 0x1F}; floraCharacteristic-\u0026gt;writeValue(buf, 2, true); delay(500); return true; } bool readFloraDataCharacteristic(BLERemoteService* floraService, String baseTopic) { BLERemoteCharacteristic* floraCharacteristic = nullptr; // get the main device data characteristic Serial.println(\u0026quot;- Access characteristic from device\u0026quot;); try { floraCharacteristic = floraService-\u0026gt;getCharacteristic(uuid_sensor_data); } catch (...) { // something went wrong } if (floraCharacteristic == nullptr) { Serial.println(\u0026quot;-- Failed, skipping device\u0026quot;); return false; } // read characteristic value Serial.println(\u0026quot;- Read value from characteristic\u0026quot;); std::string value; try{ value = floraCharacteristic-\u0026gt;readValue(); } catch (...) { // something went wrong Serial.println(\u0026quot;-- Failed, skipping device\u0026quot;); return false; } const char *val = value.c_str(); Serial.print(\u0026quot;Hex: \u0026quot;); for (int i = 0; i \u0026lt; 16; i++) { Serial.print((int)val[i], HEX); Serial.print(\u0026quot; \u0026quot;); } Serial.println(\u0026quot; \u0026quot;); int16_t* temp_raw = (int16_t*)val; float temperature = (*temp_raw) / ((float)10.0); Serial.print(\u0026quot;-- Temperature: \u0026quot;); Serial.println(temperature); int moisture = val[7]; Serial.print(\u0026quot;-- Moisture: \u0026quot;); Serial.println(moisture); int light = val[3] + val[4] * 256; Serial.print(\u0026quot;-- Light: \u0026quot;); Serial.println(light); int conductivity = val[8] + val[9] * 256; Serial.print(\u0026quot;-- Conductivity: \u0026quot;); Serial.println(conductivity); if (temperature \u0026gt; 200) { Serial.println(\u0026quot;-- Unreasonable values received, skip publish\u0026quot;); return false; } char buffer[64]; snprintf(buffer, 64, \u0026quot;%f\u0026quot;, temperature); client.publish((baseTopic + \u0026quot;temperature\u0026quot;).c_str(), buffer); snprintf(buffer, 64, \u0026quot;%d\u0026quot;, moisture); client.publish((baseTopic + \u0026quot;moisture\u0026quot;).c_str(), buffer); snprintf(buffer, 64, \u0026quot;%d\u0026quot;, light); client.publish((baseTopic + \u0026quot;light\u0026quot;).c_str(), buffer); snprintf(buffer, 64, \u0026quot;%d\u0026quot;, conductivity); client.publish((baseTopic + \u0026quot;conductivity\u0026quot;).c_str(), buffer); return true; } bool readFloraBatteryCharacteristic(BLERemoteService* floraService, String baseTopic) { BLERemoteCharacteristic* floraCharacteristic = nullptr; // get the device battery characteristic Serial.println(\u0026quot;- Access battery characteristic from device\u0026quot;); try { floraCharacteristic = floraService-\u0026gt;getCharacteristic(uuid_version_battery); } catch (...) { // something went wrong } if (floraCharacteristic == nullptr) { Serial.println(\u0026quot;-- Failed, skipping battery level\u0026quot;); return false; } // read characteristic value Serial.println(\u0026quot;- Read value from characteristic\u0026quot;); std::string value; try{ value = floraCharacteristic-\u0026gt;readValue(); } catch (...) { // something went wrong Serial.println(\u0026quot;-- Failed, skipping battery level\u0026quot;); return false; } const char *val2 = value.c_str(); int battery = val2[0]; char buffer[64]; Serial.print(\u0026quot;-- Battery: \u0026quot;); Serial.println(battery); snprintf(buffer, 64, \u0026quot;%d\u0026quot;, battery); client.publish((baseTopic + \u0026quot;battery\u0026quot;).c_str(), buffer); return true; } bool processFloraService(BLERemoteService* floraService, char* deviceMacAddress, bool readBattery) { // set device in data mode if (!forceFloraServiceDataMode(floraService)) { return false; } String baseTopic = MQTT_BASE_TOPIC + \u0026quot;/\u0026quot; + deviceMacAddress + \u0026quot;/\u0026quot;; bool dataSuccess = readFloraDataCharacteristic(floraService, baseTopic); bool batterySuccess = true; if (readBattery) { batterySuccess = readFloraBatteryCharacteristic(floraService, baseTopic); } return dataSuccess \u0026amp;\u0026amp; batterySuccess; } bool processFloraDevice(BLEAddress floraAddress, char* deviceMacAddress, bool getBattery, int tryCount) { Serial.print(\u0026quot;Processing Flora device at \u0026quot;); Serial.print(floraAddress.toString().c_str()); Serial.print(\u0026quot; (try \u0026quot;); Serial.print(tryCount); Serial.println(\u0026quot;)\u0026quot;); // connect to flora ble server BLEClient* floraClient = getFloraClient(floraAddress); if (floraClient == nullptr) { return false; } // connect data service BLERemoteService* floraService = getFloraService(floraClient); if (floraService == nullptr) { floraClient-\u0026gt;disconnect(); return false; } // process devices data bool success = processFloraService(floraService, deviceMacAddress, getBattery); // disconnect from device floraClient-\u0026gt;disconnect(); return success; } void hibernate() { esp_sleep_enable_timer_wakeup(SLEEP_DURATION * 1000000ll); Serial.println(\u0026quot;Going to sleep now.\u0026quot;); delay(100); esp_deep_sleep_start(); } void delayedHibernate(void *parameter) { delay(EMERGENCY_HIBERNATE*1000); // delay for five minutes Serial.println(\u0026quot;Something got stuck, entering emergency hibernate...\u0026quot;); hibernate(); } void setup() { // all action is done when device is woken up Serial.begin(115200); delay(1000); // increase boot count bootCount++; // create a hibernate task in case something gets stuck xTaskCreate(delayedHibernate, \u0026quot;hibernate\u0026quot;, 4096, NULL, 1, \u0026amp;hibernateTaskHandle); Serial.println(\u0026quot;Initialize BLE client...\u0026quot;); BLEDevice::init(\u0026quot;\u0026quot;); BLEDevice::setPower(ESP_PWR_LVL_P7); // connecting wifi and mqtt server connectWifi(); connectMqtt(); // check if battery status should be read - based on boot count bool readBattery = ((bootCount % BATTERY_INTERVAL) == 0); // process devices for (int i=0; i\u0026lt;deviceCount; i++) { int tryCount = 0; char* deviceMacAddress = FLORA_DEVICES[i]; BLEAddress floraAddress(deviceMacAddress); while (tryCount \u0026lt; RETRY) { tryCount++; if (processFloraDevice(floraAddress, deviceMacAddress, readBattery, tryCount)) { break; } delay(1000); } delay(1500); } // disconnect wifi and mqtt disconnectWifi(); disconnectMqtt(); // delete emergency hibernate task vTaskDelete(hibernateTaskHandle); // go to sleep now hibernate(); } void loop() { /// we're not doing anything in the loop, only on device wakeup delay(10000); } ","permalink":"https://www.debashishsahu.com/posts/esp32-communicating-with-xiaomi-flora-plant-sensor-using-ble/","summary":"Using ESP32 to communicate with Xiaomi flora (miflora) plant sensor using BLE and posting the values on MQTT server. I also demonstrate the use of Home Assistant miflora sensor component.\nChange ESP32 Partition: https://desire.giesecke.tk/index.php/2018/04/20/change-partition-size-arduino-ide/ Home Assistant miflora sensor: https://www.home-assistant.io/components/sensor.miflora/\nGitHub: sidddy/flora Archived code from https://github.com/sidddy/flora below\nconfig.h\n// array of different xiaomi flora MAC addresses char* FLORA_DEVICES[] = { \u0026quot;C4:7C:8D:67:11:11\u0026quot;, \u0026quot;C4:7C:8D:67:22:22\u0026quot;, \u0026quot;C4:7C:8D:67:33:33\u0026quot; }; // sleep between to runs in seconds #define SLEEP_DURATION 30 * 60 // emergency hibernate countdown in seconds #define EMERGENCY_HIBERNATE 3 * 60 // how often should the battery be read - in run count #define BATTERY_INTERVAL 6 // how often should a device be retried in a run when something fails #define RETRY 3 const char* WIFI_SSID = \u0026quot;ssid\u0026quot;; const char* WIFI_PASSWORD = \u0026quot;password\u0026quot;; // MQTT topic gets defined by \u0026quot;\u0026lt;MQTT_BASE_TOPIC\u0026gt;/\u0026lt;MAC_ADDRESS\u0026gt;/\u0026lt;property\u0026gt;\u0026quot; // where MAC_ADDRESS is one of the values from FLORA_DEVICES array // property is either temperature, moisture, conductivity, light or battery const char* MQTT_HOST = \u0026quot;10.","title":"ESP32 Communicating With Xiaomi Flora Plant Sensor Using BLE"},{"content":"    Trying to rescue a GPU cooling system containing a 12V 4-wire fan using a PWM signal from ATtiny85 and reading a voltage from ADC from a potentiometer knob. Ultimately building a 4-wire fan controller.\n25kHz PWM on ESP8266: https://github.com/esp8266/Arduino/issues/4598\nSoftware  ","permalink":"https://www.debashishsahu.com/posts/resurrecting-a-gpu-cooling-fan-using-a-micro-processor-and-pwm/","summary":"    Trying to rescue a GPU cooling system containing a 12V 4-wire fan using a PWM signal from ATtiny85 and reading a voltage from ADC from a potentiometer knob. Ultimately building a 4-wire fan controller.\n25kHz PWM on ESP8266: https://github.com/esp8266/Arduino/issues/4598\nSoftware  ","title":"Resurrecting a GPU Cooling Fan Using a Micro-Processor and PWM"},{"content":"    Convert a string of filament lights (X-mas decoration lights) into a LED string of lights.\nInspired from bigclive\u0026rsquo;s project   ","permalink":"https://www.debashishsahu.com/posts/building-led-string-using-capacitive-dropper/","summary":"    Convert a string of filament lights (X-mas decoration lights) into a LED string of lights.\nInspired from bigclive\u0026rsquo;s project   ","title":"Building LED String Using Capacitive Dropper"},{"content":"    An attempt to build a Amazon \u0026ldquo;Dash\u0026rdquo; type button to communicate with Home Assistant, which is a combination of two different projects\nGitHub: debsahu/TheButton Things we want to achieve:  Low on power consumtion: ESP8266 is OFF when the button is not pressed debsahu/ESP_External_Interrupt Portable: Uses 18650 battery, lasts years Talks to Home Assistant: debsahu/HARestAPI    ESP_External_Interrupt  GitHub: https://github.com/debsahu/ESP_External_Interrupt\n  HARestAPI  GitHub: https://github.com/debsahu/HARestAPI\n  ","permalink":"https://www.debashishsahu.com/posts/the-button-amazon-dash-type-button-to-communicate-to-home-assistant/","summary":"An attempt to build a Amazon \u0026ldquo;Dash\u0026rdquo; type button to communicate with Home Assistant, which is a combination of two different projects\nGitHub: debsahu/TheButton Things we want to achieve:  Low on power consumtion: ESP8266 is OFF when the button is not pressed debsahu/ESP_External_Interrupt Portable: Uses 18650 battery, lasts years Talks to Home Assistant: debsahu/HARestAPI    ESP_External_Interrupt  GitHub: https://github.com/debsahu/ESP_External_Interrupt\n  HARestAPI  GitHub: https://github.","title":"The Button: Amazon \"Dash\" Type Button to Communicate to Home-Assistant"},{"content":"    Let\u0026rsquo;s build a security camera using Raspberry Pi Zero W and Movidius Neural Compute Stick to recognize a \u0026ldquo;person\u0026rdquo; on the video stream\nGitHub: debsahu/PiCamMovidius Set up NCSDK API  Install required packages on Pi  sudo apt-get install -y libusb-1.0-0-dev libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler libatlas-base-dev git automake byacc lsb-release cmake libgflags-dev libgoogle-glog-dev liblmdb-dev swig3.0 graphviz libxslt-dev libxml2-dev gfortran python3-dev python-pip python3-pip python3-setuptools python3-markdown python3-pillow python3-yaml python3-pygraphviz python3-h5py python3-nose python3-lxml python3-matplotlib python3-numpy python3-protobuf python3-dateutil python3-skimage python3-scipy python3-six python3-networkx python3-tk libboost-python-dev  Clone NCSDK  cd ~ git clone https://github.com/movidius/ncsdk  Compile and install NCSDK’s API framework  cd ~/ncsdk/api/src make sudo make install  Test installation using sample code from NC App Zoo  cd ~ git clone https://github.com/movidius/ncappzoo cd ncappzoo/apps/hello_ncs_py python3 hello_ncs.py Output should look something like this:\nHello NCS! Device opened normally. Goodbye NCS! Device closed normally. NCS device working. Install Paho-MQTT  Use pip3 to install Paho-MQTT  pip3 install paho-mqtt sudo pip3 install paho-mqtt Using these examples  Clone this code  cd ~ git clone https://github.com/debsahu/PiCamMovidius Native MobileSSD  Enter into following directory  cd ~/PiCamMovidius/native/picam  Edit picam.py with appropiate MQTT server IP, port and topic and run python script  python3 picam.py OpenCV 3.2 YoLoV2  Install pre-compiled OpenCV 3.2 Add to apt-source list  echo 'deb [trusted=yes] http://dl.bintray.com/yoursunny/PiZero stretch-backports main' | sudo tee /etc/apt/sources.list.d/bintray-yoursunny-PiZero.list  Update apt  sudo apt update  Install OpenCV  sudo apt install python3-opencv  Verify Install  python3 -c 'import cv2; print(cv2.__version__)'  Enable V4L driver  sudo modprobe bcm2835-v4l2  Enter into following directory  cd ~/PiCamMovidius/ocv3 make  Edit picam.py with appropiate MQTT server IP, port and topic and run python script  python3 picam.py ","permalink":"https://www.debashishsahu.com/posts/image-recognition-using-movidius-neural-compute-stick-on-a-rpi0w/","summary":"Let\u0026rsquo;s build a security camera using Raspberry Pi Zero W and Movidius Neural Compute Stick to recognize a \u0026ldquo;person\u0026rdquo; on the video stream\nGitHub: debsahu/PiCamMovidius Set up NCSDK API  Install required packages on Pi  sudo apt-get install -y libusb-1.0-0-dev libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler libatlas-base-dev git automake byacc lsb-release cmake libgflags-dev libgoogle-glog-dev liblmdb-dev swig3.0 graphviz libxslt-dev libxml2-dev gfortran python3-dev python-pip python3-pip python3-setuptools python3-markdown python3-pillow python3-yaml python3-pygraphviz python3-h5py python3-nose python3-lxml python3-matplotlib python3-numpy python3-protobuf python3-dateutil python3-skimage python3-scipy python3-six python3-networkx python3-tk libboost-python-dev  Clone NCSDK  cd ~ git clone https://github.","title":"Image Recognition Using Movidius Neural Compute Stick on a RPi0W"},{"content":"    Wouldn\u0026rsquo;t be cool for many McLighting (RGB LED lighting using NeoPixels) to talk to each other and synchronize? Here is my naive attempt at this, which requires McLighting to be served as stand-alone web-client.\nMeshyMcLighting What is this? Wouldn\u0026rsquo;t be cool for many McLighting to talk to each other and synchronize? Here is my naive attempt at this, which requires McLighting to be served as stand-alone webclient.\nFeatures  Uses painlessMesh to create mesh network and broadcasts state to every node Does not need WiFi connection to internet, standalone mode + mesh Web interface is borrowed from \u0026ldquo;WS2812FX esp8266\u0026rdquo; example, completely served on ESP8266 Can do minimal file upload to SPIFFs Completely Async! Uses Task Scheduler, no more tickers No delays in entire code Has RESTful API (same API as McLighting, use set_mode for setting mode, speed, brighness) Async Websockets (ws://HOSTNAME/ws on port 80, same API as McLighting) Async MQTT/Home Assistant Intergration (Only SERVER connects to outside world) Auto Mode (same as McLighting) Button Mode (same as McLighting) Async WiFiManager for SERVER  Limitations/TODO  For stability, compile both SERVER and CLIENTS on IwIP variant 1.4 Higher Bandwidth (very flaky in IwIP v2) Use Arduino ESP8266 GIT version (Issues with v2.4.1: not memory optimized) WS2812FX has delays meant for ESP32. Track issue here NeoAnimationFX has no delays.  Issues where help is needed  All issues mentioned in limitations  How to use this? For stability reasons, compile both SERVER and CLIENTS on IwIP variant 1.4 Higher Bandwidth\nSERVER (Connects to outside world: WiFi/MQTT/HA)\n Compile SERVER first and upload. Using a phone, connect to WiFi named \u0026ldquo;MeshyMcLighting\u0026rdquo; or whatever is set as HOSTNAME in definitions.h Enter router WiFi SSID and Password After sucessful connection, look in \u0026ldquo;Serial Monitor\u0026rdquo; for WiFi channel of the connected WiFi. It will be same channel set on your WiFi router.  CLIENTS (Connects to Server)\n Take a note of this WiFi channel and enter it in #define STATION_WIFI_CHANNEL wifi_channel_from_previous_step in definitions.h in clients Compile Clients with this updated value Do not enable webserver for clients  Libraries to install In Arduino, Goto Sketch -\u0026gt; Include Library -\u0026gt; Add .ZIP Library\u0026hellip; and point to the zip file downloaded.\n Painless Mesh Arduino JSON Task Scheduler Async TCP Async Web Server Async MQTT Client Async WiFiManager  LED libraries In definitions.h: #define USE_WS2812FX See changes needed with WS2818FX\n WS2812FX Adafruit NeoPixels  or\nIn definitions.h: #define USE_NEOANIMATIONFX\n NeoAnimationFX NeoPixelBus  ","permalink":"https://www.debashishsahu.com/posts/meshymclighting-neopixels-lighting-solution-using-mesh-network/","summary":"Wouldn\u0026rsquo;t be cool for many McLighting (RGB LED lighting using NeoPixels) to talk to each other and synchronize? Here is my naive attempt at this, which requires McLighting to be served as stand-alone web-client.\nMeshyMcLighting What is this? Wouldn\u0026rsquo;t be cool for many McLighting to talk to each other and synchronize? Here is my naive attempt at this, which requires McLighting to be served as stand-alone webclient.","title":"MeshyMcLighting: NeoPixels Lighting Solution Using Mesh Network"},{"content":"    An attempt to use RTL-SDR to read values from wireless electric/gas/water meters and visualize these values on Home Assistant.\nSoftware Based on bemasher/RTLAMR Project: https://github.com/bemasher/rtlamr\n ","permalink":"https://www.debashishsahu.com/posts/using-rtl-sdr-to-read-values-from-wireless-electric-gas-water-meters/","summary":"    An attempt to use RTL-SDR to read values from wireless electric/gas/water meters and visualize these values on Home Assistant.\nSoftware Based on bemasher/RTLAMR Project: https://github.com/bemasher/rtlamr\n ","title":"Using RTL-SDR to Read Values From Wireless Electric/Gas/Water Meters"},{"content":"    A simple Arduino library that retrieves live stock prices from www.robinhood.com in JSON format and processes it for ESP8266. In one example, we demonstrate a whole bunch of stock prices scrolling through a dot-matrix display.\nGithub: debsahu/RobinhoodAPI An Arduino library to talk to Robin Hood using non-documented Rest API made for ESP8266. Some unofficial documentaion by @sanko is available at here]\nUsing the Library  Download this GitHub library. In Arduino, Goto Sketch -\u0026gt; Include Library -\u0026gt; Add .ZIP Library\u0026hellip; and point to the zip file downloaded. Install ArduinoJSON (mandatory: Reply from RobinHood is JSON) using the same process.  To use in your sketch include these lines.\n#include \u0026lt;ESP8266WiFi.h\u0026gt; #include \u0026lt;RobinhoodAPI.h\u0026gt; Declare WiFiClientSecure and pass it to RobinhoodAPI.\nString fp_robinhood_042018 = \u0026quot;8F C1 46 FB 19 0A 16 FF F7 D1 E6 48 5C 74 54 0E 00 FF 36 A6\u0026quot;; // update with latest fp from https://www.grc.com/fingerprints.htm WiFiClientSecure sclient; //RobinhoodAPI rh(sclient); // Declare API with no fingerprint check! RobinhoodAPI rh(sclient, fp_robinhood_042018); // Declare API with fingerprint check Using the API to get live stock values.\nString stocksybl = \u0026quot;TSLA\u0026quot;; if(rh.getStockQuote(stocksybl)) { Serial.println(stocksybl); Serial.printf(\u0026quot;Latest Price : %.2f\\n\u0026quot;, rh.lastTradePrice()); Serial.printf(\u0026quot;Percent Change: %.2f%%\\n\u0026quot;, rh.percentDiff()); } ","permalink":"https://www.debashishsahu.com/posts/robinhoodapi-live-stock-prices-from-robinhood-on-esp8266/","summary":"A simple Arduino library that retrieves live stock prices from www.robinhood.com in JSON format and processes it for ESP8266. In one example, we demonstrate a whole bunch of stock prices scrolling through a dot-matrix display.\nGithub: debsahu/RobinhoodAPI An Arduino library to talk to Robin Hood using non-documented Rest API made for ESP8266. Some unofficial documentaion by @sanko is available at here]\nUsing the Library  Download this GitHub library.","title":"RobinhoodAPI: Live Stock Prices From Robinhood on ESP8266"},{"content":"    This video is a collaboration with my wife who does \u0026ldquo;machine learning on big data\u0026rdquo; for a living. Here is a naive attempt at predicting a particular stock\u0026rsquo;s price and displaying it on a ESP8266. This algorithm is not the best one out there, but what is being shown here is the ability to port it elsewhere and easily integrate these complex models with micro-controllers (ESP8266) and other devices.\nGitHub:debsahu/StockPredictionPython  Install MATLAB 2017a Runtime v9.2 from here Goto Python/matlab_stock_python_lib folder and install stock python library using python setup.py install Use requirements.txt file to install required libraries. Console: $ pip -r install requirements.txt Enter appropriate values for MQTT server in upload_stock_pred.py and run python upload_stock_pred.py Upload Arduino files on your esp8266 using Arduino IDE  ","permalink":"https://www.debashishsahu.com/posts/stock-prediction-on-python-using-machine-learning-narx/","summary":"This video is a collaboration with my wife who does \u0026ldquo;machine learning on big data\u0026rdquo; for a living. Here is a naive attempt at predicting a particular stock\u0026rsquo;s price and displaying it on a ESP8266. This algorithm is not the best one out there, but what is being shown here is the ability to port it elsewhere and easily integrate these complex models with micro-controllers (ESP8266) and other devices.","title":"Stock Prediction on Python Using Machine Learning (NARX)"},{"content":"    Control components on Home Assistant directly from ESP8266. This is an Arduino Library that can be used in various projects without the requirement of setup of a MQTT sensor + automation on HA. This uses RESTful API commands.\nIdea  Control components on Home Assistant directly from ESP8266.  Implementation  Develop an Arduino Library that can be used in various projects without the requirement of setup of a MQTT sensor + automation on HA. This uses RESTful API commands.  HARestAPI Library: https://github.com/debsahu/HARestAPI An Arduino library to talk to Home Assistant using Rest API made for ESP8266.\nBeta  Can do POST effectively and not GET (reply is too long for esp8266). Try using sendGetHA(URL,Component) and provide feedback.  Using the Library  Download this GitHub library. In Arduino, Goto Sketch -\u0026gt; Include Library -\u0026gt; Add .ZIP Library\u0026hellip; and point to the zip file downloaded.  To use in your sketch include these lines.\n#include \u0026lt;HARestAPI.h\u0026gt; Declare clients before setup(). If using HA with no SSL declare WiFiClient and pass it to HARestAPI.\nWiFiClient client; HARestAPI ha(client); If using HA with SSL declare WiFiClientSecure and pass it to HARestAPI.\nWiFiClientSecure sclient; HARestAPI ha(sclient); In setup make sure to setup IP and port of HA server. Default is 8123 and if using SSL 443.\nconst char* ha_ip = \u0026quot;192.168.0.xxx\u0026quot;; uint16_t ha_port = 8123; const char* ha_pwd = \u0026quot;HA_PASSWORD\u0026quot;; //long-lived password. On HA, Profile \u0026gt; Long-Lived Access Tokens \u0026gt; Create Token ha.setHAServer(ha_ip, ha_port); ha.setHAPassword(ha_pwd); // Optional, but can use SHA1 fingerprint to confirm one is connecting to String fingerprint = \u0026quot;35 85 74 EF 67 35 A7 CE 40 69 50 F3 C0 F6 80 CF 80 3B 2E 19\u0026quot;; ha.setFingerPrint(fingerprint); All the commands below do the same thing\nHome Assistant\nURL: \u0026ldquo;/api/services/light/turn_on\u0026rdquo; (HA -\u0026gt; Developer Tools -\u0026gt; Services -\u0026gt; Service)\nComponent: \u0026ldquo;light.bedroom_light\u0026rdquo; (HA -\u0026gt; Developer Tools -\u0026gt; Services -\u0026gt; Entity)\n // 1. Send custom DATA to HA ha.sendCustomHAData(\u0026quot;/api/services/light/turn_on\u0026quot;, \u0026quot;{\\\u0026quot;entity_id\\\u0026quot;:\\\u0026quot;light.bedroom_light\\\u0026quot;}\u0026quot;);  // 2. Set component and send light to HA // Will set tmpURL to \u0026quot;/api/services/light/turn_on\u0026quot; ha.setComponent(\u0026quot;light.bedroom_light\u0026quot;); ha.sendHALight(true);  // 3. Set light on/off as bool and component is 2nd input, Send Light to HA // Will set tmpURL to \u0026quot;/api/services/light/turn_on\u0026quot; ha.sendHALight(true, \u0026quot;light.bedroom_light\u0026quot;);  // 4. Set component and URL is 2nd input, Send custom URL to HA ha.setComponent(\u0026quot;light.bedroom_light\u0026quot;); ha.sendHAURL(\u0026quot;/api/services/light/turn_on\u0026quot;);  // 5. Set URL and Send component to HA ha.setURL(\u0026quot;/api/services/light/turn_on\u0026quot;); ha.sendHAComponent(\u0026quot;light.bedroom_light\u0026quot;);  // 6. Set URL 1st argument, component 2nd, send to HA ha.sendHAComponent(\u0026quot;/api/services/light/turn_on\u0026quot;, \u0026quot;light.bedroom_light\u0026quot;);  // 7. Set URL , Set component, send to HA ha.setURL(\u0026quot;/api/services/light/turn_on\u0026quot;); ha.setComponent(\u0026quot;light.bedroom_light\u0026quot;); ha.sendHA(); ","permalink":"https://www.debashishsahu.com/posts/harestapi-control-home-assistant-directly-using-esp8266/","summary":"Control components on Home Assistant directly from ESP8266. This is an Arduino Library that can be used in various projects without the requirement of setup of a MQTT sensor + automation on HA. This uses RESTful API commands.\nIdea  Control components on Home Assistant directly from ESP8266.  Implementation  Develop an Arduino Library that can be used in various projects without the requirement of setup of a MQTT sensor + automation on HA.","title":"HARestAPI: Control Home Assistant Directly Using ESP8266"},{"content":"    Did you ever want to use ESP8266 to communicate to Home Assistant directly? Here we use a TCS34725 color sensor to read colors and change a RGB light in Home Assistant to the color observed.\nHardware  TCS34725 color sensor SSD 1306 OLED Wemos D1 mini (ESP8266)  Software  RGB Lights connected to Home Assistant  toblum/McLighting Aircoookie/WLED  ","permalink":"https://www.debashishsahu.com/posts/esp8266-based-color-sensor-talking-to-home-assistant-via-restapi/","summary":"    Did you ever want to use ESP8266 to communicate to Home Assistant directly? Here we use a TCS34725 color sensor to read colors and change a RGB light in Home Assistant to the color observed.\nHardware  TCS34725 color sensor SSD 1306 OLED Wemos D1 mini (ESP8266)  Software  RGB Lights connected to Home Assistant  toblum/McLighting Aircoookie/WLED  ","title":"ESP8266 Based Color Sensor Talking to Home Assistant via RestAPI"},{"content":"    Idea:  Use ESP8266 to talk to Twitter Get User Data or Tweet or Search Twitter Display the data on a Dot-Matrix display  Implementation I created an Arduino library to talk to Twitter using its Web API made for ESP8266. There are other approaches like using a bearer token arduino-twitter-api, but comes with limitations in terms of not being able to send tweet. This Arduino library TwitterWebAPI can both search/read and post tweets.\nAll the instructions and usage of library is described on my GitHub library page Github: debsahu/TwitterWebAPI\n TwitterWebAPI An Arduino library to talk to Twitter using Twitter Web API made for ESP8266. This is based on a sketch posted here. There are other approaches like using a bearer token arduino-twitter-api, but there are limitations in terms of not being able to send tweet. This can both search/read and post tweets.\nConsumer Key, Consumer Secret, Access Token \u0026amp; Access Token Secret In order to talk to Twitter,\n Goto https://apps.twitter.com/app/new and sign in (if you havent already). Fill in the fields, For website you can enter any webpage (e.g. http://google.com), and create your app Then click on the Keys \u0026amp; Tokens tab. Your Consumer Key and Consumer Secret will be there, if not click on Generate.  Fill the obtained Consumer Key, Consumer Secret, Access Token and Access Token Secret inside the sketch.\nUsing the Library  Download this GitHub library. In Arduino, Goto Sketch -\u0026gt; Include Library -\u0026gt; Add .ZIP Library\u0026hellip; and point to the zip file downloaded. Install TimeLib library and NTPClient library using the same procedure.  To use in your sketch include these lines.\n#include \u0026lt;TwitterWebAPI.h\u0026gt; #include \u0026lt;NTPClient.h\u0026gt; #include \u0026lt;WiFiUdp.h\u0026gt; Define Twitter GET request timeout (optional, default is 1500ms)\n#define TWI_TIMEOUT 2000 // in msec Setup correct timezone to correct the time obtained from NTP server.\nconst char *ntp_server = \u0026quot;pool.ntp.org\u0026quot;; // time1.google.com, time.nist.gov, pool.ntp.org int timezone = -5; // US Eastern timezone -05:00 HRS You WILL need Consumer Key, Consumer Secret, Access Token and Access Token Secret that can be obtained from the above steps.\n// Values below are just a placeholder // Obtain these by creating an app @ https://apps.twitter.com/ static char const consumer_key[] = \u0026quot;gkyjeH3EF32NJfiuheuyf8623\u0026quot;; static char const consumer_sec[] = \u0026quot;HbY5h$N86hg5jjd987HGFsRjJcMkjLaJw44628sOh353gI3H23\u0026quot;; static char const accesstoken[] = \u0026quot;041657084136508135-F3BE63U4Y6b346kj6bnkdlvnjbGsd3V\u0026quot;; static char const accesstoken_sec[] = \u0026quot;bsekjH8YT3dCWDdsgsdHUgdBiosesDgv43rknU4YY56Tj\u0026quot;; Declare clients before setup().\nWiFiUDP ntpUDP; NTPClient timeClient(ntpUDP, ntp_server, timezone*3600, 60000); // NTP server pool, offset (in seconds), update interval (in milliseconds) TwitterClient tcr(timeClient, consumer_key, consumer_sec, accesstoken, accesstoken_sec); In setup make sure to start NTP connection. A correct time is required to be able to post/search on Twitter.\ntcr.startNTP(); Search for a key word\nstd::string search_str; String tmsg = tcr.searchTwitter(search_str); Search Twitter User Info (eg follower count)\nstd::string search_str; tcr.searchUser(search_str); Post to Twitter\nstd::string twitter_post_msg; tcr.tweet(twitter_post_msg); Example: TwitterTweetSearchFSWiFiMgr In addition to TwitterWebAPI, make sure that TimeLib library and NTPClient library is installed, and install the following libraries\n Arduino JSON WiFiManager  For display you can either install\n MAX7219 library or MD Parola \u0026amp; MD_Max72xx  Previous idea  Too many variables on the pathway IFTTT is not the most responsive    ","permalink":"https://www.debashishsahu.com/posts/talking-to-twitter-using-twitterwebapi-for-esp8266/","summary":"Idea:  Use ESP8266 to talk to Twitter Get User Data or Tweet or Search Twitter Display the data on a Dot-Matrix display  Implementation I created an Arduino library to talk to Twitter using its Web API made for ESP8266. There are other approaches like using a bearer token arduino-twitter-api, but comes with limitations in terms of not being able to send tweet. This Arduino library TwitterWebAPI can both search/read and post tweets.","title":"Talking to Twitter Using TwitterWebAPI for ESP8266"},{"content":"    Have you wondered how to build a internet connected smoke alarm using ESP8266 and a cheap Kidde RF-SM-DC?\nOverall idea is to detect smoke alarm signals and send MQTT message. Home Assistant reads the MQTT message and sends out notifications that can be used to notify your local fire station.\nESP8266 sends a MQTT message until the smoke alarm is beeping.\nSoftware Refer to https://github.com/debsahu/ESP_External_Interrupt to build the ESP8266 part of the internet connected smoke alarm.\n   Github: debsahu/ESP_External_Interrupt\nHardware Overall idea is to detect smoke alarm signals and send MQTT message. Home Assistant reads the MQTT message and sends out notifications that can be used to notify your local fire station.\nWe will be hacking into Kidde RF-SM-DC\nZoomed Kidde RF-SM-DC\u0026rsquo;s location of 3.3V signal\n","permalink":"https://www.debashishsahu.com/posts/internet-connected-smoke-alarm/","summary":"Have you wondered how to build a internet connected smoke alarm using ESP8266 and a cheap Kidde RF-SM-DC?\nOverall idea is to detect smoke alarm signals and send MQTT message. Home Assistant reads the MQTT message and sends out notifications that can be used to notify your local fire station.\nESP8266 sends a MQTT message until the smoke alarm is beeping.\nSoftware Refer to https://github.com/debsahu/ESP_External_Interrupt to build the ESP8266 part of the internet connected smoke alarm.","title":"Internet Connected Smoke Alarm"},{"content":"    Have you ever wondered how to turn on ESP8266 using external interrupt? Build a battery powered amazon dash button or a 18650 lipo powered door bell using ESP8266 without putting the device in deep sleep? Here is your answer.\nIdea  Keep ESP8266 on OFF mode as default External 3.3V signal (can be short or long) arrives and turns ON ESP8266 ESP8266 wakes up and keeps itself awake until a task is perfomed Send MQTT data to server Put ESP8266 back to power OFF state  Implementation  RST pin is always HIGH/3.3V using 10k resistor ESP8266 is in OFF state, GPIO0 is low 3.3V signal arrives externally, GPIO0 and CH_PD are high, turn ON ESP8266 First thing ESP8266 does is turns GPIO0 to high, which means CH_PD remain high. So ESP8266 remains ON until GPIO0 is high GPIO12 is used to read value of external interupt If there is 3.3V external interrupt, GPIO is high and a MQTT message is sent as “Signal Received” or “ON” and keep ESP8266 ON until 0V signal is received. If there is 0V external interrupt, GPIO0 goes low and MQTT message is sent as “Signal Vanished” or “OFF” and turns OFF ESP8266  Software This project is built using ideas at http://www.esp8266.com/viewtopic.php?f=11\u0026amp;t=4458\nGithub: debsahu/ESP_External_Interrupt\nBuild ","permalink":"https://www.debashishsahu.com/posts/extreme-power-save-mode-esp8266-powered-on-after-external-interrupt/","summary":"Have you ever wondered how to turn on ESP8266 using external interrupt? Build a battery powered amazon dash button or a 18650 lipo powered door bell using ESP8266 without putting the device in deep sleep? Here is your answer.\nIdea  Keep ESP8266 on OFF mode as default External 3.3V signal (can be short or long) arrives and turns ON ESP8266 ESP8266 wakes up and keeps itself awake until a task is perfomed Send MQTT data to server Put ESP8266 back to power OFF state  Implementation  RST pin is always HIGH/3.","title":"Extreme Power-Save Mode: ESP8266 Powered ON After External Interrupt"},{"content":"    Wouldn’t it be nice to know if your dog’s water bowl is empty? Let us build a sensor that measures the water level every 5 minutes. This value is sent to MQTT server and Home Assistant automation takes care of the rest.\nThis sensor connects to MQTT and Home Assistant. See dogsensor.yaml for adding this to HA. Assumes that one has set up various notification sensors available in HA.\nHardware  3D Printed Case 18650 Battery ESP8266 12E Rain Water Level Sensor  Software Github: debsahu/DogWaterSensor\nUse Arduino IDE to upload code on ESP8266 by connecting GPIO0 to Ground. For Deep-Sleep to work one has to conenct GPIO16 to RESET on ESP8266.\nThis sensor connects to MQTT and Home Assistant (https://home-assistant.io/). See dogsensor.yaml for adding this to HA. Assumes that one has set up various notification sensors (https://home-assistant.io/components/#notifications) available in HA.\nSchematic ","permalink":"https://www.debashishsahu.com/posts/internet-connected-dog-water-bowl-sensor/","summary":"Wouldn’t it be nice to know if your dog’s water bowl is empty? Let us build a sensor that measures the water level every 5 minutes. This value is sent to MQTT server and Home Assistant automation takes care of the rest.\nThis sensor connects to MQTT and Home Assistant. See dogsensor.yaml for adding this to HA. Assumes that one has set up various notification sensors available in HA.","title":"Internet Connected Dog Water Bowl Sensor"},{"content":"    Lets turn on and off low powered fan running at low (\u0026lt;20V) DC voltages. We shall use a MOSFET to achieve this. Hardware  IRLML0030PBF ATTiny85 2-pin 12V Fan  Wiring MOSFETs have three terminals Drain (D), Source (S) and Gate (G), where source is connected to ground and the +12V or +5V along with load (Fan) is connected to drain. The MOSFET is on when gate voltage is higher than 1.7V and turned off when gate voltage is 0V.\nThis signal can be given out from a micro-controller as 3.3V/5V or 0V signals.\n","permalink":"https://www.debashishsahu.com/posts/mosfet-used-as-switch-to-control-a-12v-fan/","summary":"Lets turn on and off low powered fan running at low (\u0026lt;20V) DC voltages. We shall use a MOSFET to achieve this. Hardware  IRLML0030PBF ATTiny85 2-pin 12V Fan  Wiring MOSFETs have three terminals Drain (D), Source (S) and Gate (G), where source is connected to ground and the +12V or +5V along with load (Fan) is connected to drain. The MOSFET is on when gate voltage is higher than 1.","title":"MOSFET Used as Switch to Control a 12V Fan"},{"content":"    Here are the instructions to wire a stable AMS1117-3.3 voltage regulator properly. This can power an ESP8266 or any 3.3V micro-controller reliably supporting current draws up to 1A.\nHardware  AMS 1117-3.3 10 uF Electrolytic Capacitor 104 Ceramic Capacitor  Wiring AMS1117-3.3 (right to left)  Pin 1: GND Pin 2: Vout Pin 3: Vin  Connections  5-12V -\u0026gt; Vin GND -\u0026gt; GND 10 uF Electrolytic Capacitor +ve -\u0026gt; Vout 10 uF Electrolytic Capacitor GND -\u0026gt; GND 104 Ceramic Capacitor +ve -\u0026gt; Vin 104 Ceramic Capacitor GND -\u0026gt; GND  ","permalink":"https://www.debashishsahu.com/posts/how-to-build-a-3-3v-voltage-regulator/","summary":"    Here are the instructions to wire a stable AMS1117-3.3 voltage regulator properly. This can power an ESP8266 or any 3.3V micro-controller reliably supporting current draws up to 1A.\nHardware  AMS 1117-3.3 10 uF Electrolytic Capacitor 104 Ceramic Capacitor  Wiring AMS1117-3.3 (right to left)  Pin 1: GND Pin 2: Vout Pin 3: Vin  Connections  5-12V -\u0026gt; Vin GND -\u0026gt; GND 10 uF Electrolytic Capacitor +ve -\u0026gt; Vout 10 uF Electrolytic Capacitor GND -\u0026gt; GND 104 Ceramic Capacitor +ve -\u0026gt; Vin 104 Ceramic Capacitor GND -\u0026gt; GND  ","title":"How to Build a 3.3V Voltage Regulator"},{"content":"    Let’s say that you don’t have your smartphone around and someone mentions you on twitter. Wouldn’t it be nice to have a display that automatically reads your twitter mentions and show it on a scrolling display? So let’s build a internet controlled (IoT) dot-matrix display that does this for us using an ESP8266.\nThe plan to accomplish this is as follows:  Someone mentions us on twitter (in my case @debsahu) IF This Then That (IFTTT) tracks these mentions and posts this data on Adafruit.io (MQTT Broker) An ESP8266 connects to Adafruit.io and shows this data on a Dot-Matrix display  We can’t control who mentions us on twitter, so we move to the second step in our plan to configure IFTTT and Adafruit.io.\nTo setup a data feed (MQTT topic) on Adafruit.io,  Goto “feed” and “Create New Feed” Provide a unique name for the feed like “twitter-calls”, this means the MQTT topic that we need to subscribe to is “feed/twitter-calls”  To setup IFTTT to connect to twitter and Adafruit.io,  Connect your twitter and Adafruit.io account to IFTTT by logging in and giving proper permissions Create a new applet For “this“: Select “twitter” and “New mention of you” For “that“: Select “Adafruit” and “Send data to Adafruit.io”. Remember to select the correct topic created above and a message template using ingredients that suits your need.  As a part of the third step in our plan, we need to subscribe to our MQTT topic and display this data on a Dot-Matrix display.\nHardware  Wemos D1 mini (ESP8266) Max7219 Dot Matrix Display  Software  Setup Arduino IDE to be able to program an ESP8266 (Instructions on how to do this is here as well as in the video below). Install Adafruit_MQTT and MAX7219 Dot-Matrix display libraries    Library Link     Adafruit.io MQTT https://github.com/adafruit/Adafruit_MQTT_Library   Max7219 https://github.com/SensorsIot/MAX7219-4-digit-display-Library-for-ESP8266-     Upload the code found here on your ESP8266  Wiring Make these following connections between Max 7219 display and Wemos D1:\n VCC -\u0026gt; 5V GND -\u0026gt; GND DIN -\u0026gt; D7 CS -\u0026gt; D8 CLK -\u0026gt; D5  That’s it, now you should be able to see your latest twitter mentions on your Dot-Matrix displays.\n","permalink":"https://www.debashishsahu.com/posts/iot-dot-matrix-display-twitter-mentions-using-esp8266-adafruit-io-and-ifttt/","summary":"Let’s say that you don’t have your smartphone around and someone mentions you on twitter. Wouldn’t it be nice to have a display that automatically reads your twitter mentions and show it on a scrolling display? So let’s build a internet controlled (IoT) dot-matrix display that does this for us using an ESP8266.\nThe plan to accomplish this is as follows:  Someone mentions us on twitter (in my case @debsahu) IF This Then That (IFTTT) tracks these mentions and posts this data on Adafruit.","title":"IoT Dot Matrix Display: Twitter Mentions Using ESP8266 Adafruit.io and IFTTT"}]